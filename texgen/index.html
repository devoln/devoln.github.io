<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>SynthGen</title>
<link rel="stylesheet" type="text/css" href="styles.css">
</head>

<body>
<noscript><font size=4 color=red><b>This app requires enabled JavaScript in browser!</b></font></noscript>
<div id="eApp" class="app hidden">
<header class="main">
  <div class="menu-bar">
    <label>{{ userLogin }}/</label><input type="text" v-model="name"/>
    <a class="action"
      v-bind:class="{ highlight: hasUnsharedChanges }"
      v-bind:title="loc.saveLinkHotKey"
      onclick="Save(true)">{{ loc.saveLink }}</a>
    <a class="action"
      v-bind:class="{ highlight: hasUnsavedChanges }"
      v-bind:title="loc.saveToFileHotKey"
      onclick="SaveToFile()">{{ loc.saveToFile }}</a>
    <a class="action"
      v-bind:class="{ highlight: needRegenerate }"
      v-bind:title="loc.generateHotKey"
      onclick="Generate()">{{ loc.generate }}</a>
	</div>
  <div class="info">
    <div class="last-update" v-show="createdAt">
      {{ loc.created }}:
      <span class="value">{{ createdAtLocal }}</span>
      {{ loc.saved }}:
      <span class="value">{{ updatedAtLocal }}</span>
    </div>
  </div>
</header>
<div class="main-layout">
  <div class="area editors" data-tabs="yes">
    <div class="tabs">
      <div data-tab="js" class="tab tab-active">JavaScript<span id="js-filename" class="filename">({{ loc.controlCode }})</span></div>
      <div data-tab="glsl" class="tab">GLSL<span id="glsl-filename" class="filename">({{ loc.shaderCode }})</span></div>
    </div>
    <div class="pages">
      <div data-page="js" class="page page-active">
        <editor editor-id="eCode" theme="twilight" :content="js" lang="javascript" v-on:change-content="onChangeJS"></editor>
      </div>
      <div data-page="glsl" class="page">
        <editor editor-id="eShaderCode" theme="twilight" :content="glsl" lang="glsl" v-on:change-content="onChangeGLSL"></editor>
      </div>
    </div>
  </div>

  <div class="splitter" data-splitter="yes"></div>

  <div class="result">
      <div class="area" data-tabs="yes" id="eRightArea">
          <div class="tabs" id="eRightTabs">
            <div data-tab="result" class="tab tab-active">{{ loc.result }}</div>
            <div data-tab="docs" class="tab">{{ loc.documentation }}<span class="filename">({{ loc.glslFunctionPrototypes }})</span></div>
          </div>
          <div class="pages" id="eRightPages">
            <div data-page="result" class="page page-active" style="height:100%;overflow:hidden">
              <iframe id="eResultFrame" sandbox="allow-scripts allow-modals" src="result.html"></iframe>
            </div>
            <div data-page="docs" class="page" id="eDocs">
            </div>
          </div>
        </div>
  </div>
</div>
<footer class="status">
  
</footer>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.1/ace.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.1/ext-language_tools.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.1/mode-html.js"></script>
<script src="utils.js"></script>
<script src="httpapi.js"></script>
<script src="state.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.21/vue.js"></script>


<script>

ace.require("ace/ext/language_tools");

Vue.component('Editor', {
	template: '<div :id="editorId" style="position: relative; width: 100%; height: 100%;"></div>',
  props: ['editorId', 'content', 'lang', 'theme'],
  data: function() {
    return {
      editor: Object,
      beforeContent: ''
    }
  },
  watch: {
    content: function(value) {
    	if (this.beforeContent !== value) {
      	this.editor.setValue(value, 1)
      }
    }
  },
  mounted: function() {
  	var lang = this.lang || 'text'
    var theme = this.theme || 'github'

  
    this.editor = window.ace.edit(this.editorId)
    this.editor.setValue(this.content, 1)

    document.getElementById(this.editorId).editor = this.editor
    
    this.editor.getSession().setMode("ace/mode/" + lang)
    this.editor.setTheme("ace/theme/" + theme)


    this.editor.commands.bindKeys({"ctrl-l": null});
    this.editor.$blockScrolling = Infinity;
    this.editor.setFontSize(16);
	  this.editor.setOptions({
      enableBasicAutocompletion: true,
      enableSnippets: true,
      enableLiveAutocompletion: true
    });

    var t = this

    this.editor.on('change', function() {
    	t.beforeContent = t.editor.getValue()
      t.$emit('change-content', t.editor.getValue())
    })
  }
})

var localizations = {
  ru: {
    saveLink: "Сохранить ссылку",
    saveLinkHotKey: "Горячая клавиша F6 или Ctrl+L",
    saveToFile: "Сохранить в файл",
    saveToFileHotKey: "Горячая клавиша Ctrl+S",
    generateHotKey: "Горячая клавиша Shift+Enter",
    generate: "Генерировать",
    created: "Создано",
    saved: "Сохранено",
    never: "никогда",
    result: "Результат",
    controlCode: "управляющий код",
    shaderCode: "код шейдеров",
    documentation: "Документация",
    glslFunctionPrototypes: "прототипы GLSL-функций"
  },
  en: {
    saveLink: "Save link",
    saveLinkHotKey: "Hotkey F6 or Ctrl+L",
    saveToFile: "Save to file",
    saveToFileHotKey: "Hotkey Ctrl+S",
    generateHotKey: "Hotkey Shift+Enter",
    generate: "Generate",
    created: "Created",
    saved: "Saved",
    never: "never",
    result: "Result",
    controlCode: "control code",
    shaderCode: "shader code",
    documentation: "Documentation",
    glslFunctionPrototypes: "GLSL function prototypes"
  }
}

var app = new Vue({
  el: '#eApp',
  data: {
    sharedJS: "",
    sharedGLSL: "",
    savedJS: "",
    savedGLSL: "",
    generatedJS: "",
    generatedGLSL: "",
    name: "",
    gistId: null,
    userLogin: "",
    userToken: null,
    loadedSynthgenUserLogin: null,
    loadedSynthgenName: null,
    createdAt: null,
    updatedAt: null,
    js: 'CanvasSize = [1024, 1024];\nTexture.FromShader("GetPixelColor(TexCoord)").Export("tex");\n',
    glsl: 'vec3 GetPixelColor(vec2 xy)\n{\n\tfloat factor = 0.5 + PerlinOctaves(xy*10.0, vec2(10.0), 10)*0.5;\n\treturn HSV2RGB(vec3(factor*2.0*PI, 0.8, 0.7));\n}\n',
    loc: localizations.en
  },
  mounted: function() {
    this.loc = navigator.language.startsWith("ru")? localizations.ru: localizations.en
    this.userLogin = GetCookie("userLogin") || null
    this.userToken = GetCookie("userToken") || null
    eApp.classList.remove("hidden");
  },
  computed: {
    createdAtLocal: function() {return this.createdAt? this.createdAt.toLocaleString(): this.loc.never},
    updatedAtLocal: function() {return this.updatedAt? this.updatedAt.toLocaleString(): this.loc.never},
    hasUnsharedChanges: function() {return this.js != this.sharedJS || this.glsl != this.sharedGLSL},
    hasUnsavedChanges: function() {return this.js != this.savedJS || this.glsl != this.savedGLSL},
    needRegenerate: function() {return this.js != this.generatedJS || this.glsl != this.generatedGLSL}
  },
  methods: {
  	onSave: function() {
    	this.savedJS = this.js
      this.savedGLSL = this.glsl
    },
    onShare: function() {
    	this.sharedJS = this.js
      this.sharedGLSL = this.glsl
      this.onSave()
    },
    onGenerate: function() {
      this.generatedJS = this.js
      this.generatedGLSL = this.glsl
    },
    onChangeJS: function(val) {
    	if(this.js !== val)
      	this.js = val
    },
    onChangeGLSL: function(val) {
    	if(this.glsl !== val)
      	this.glsl = val
    },
    onAuth: function(userLogin, userToken) {
      this.userLogin = userLogin
      this.userToken = userToken
    }
  }
})
app.onShare();

function AddAutoCompletion(editor, wordList)
{
  var staticWordCompleter = {
      getCompletions: function(editor1, session, pos, prefix, callback) {
        if(eCode.editor == editor1) callback(null, wordList.map(function(word) {
          var caption = word[0];
          if(word[1] != null) caption += "(" + word[1].join(", ") + ")";
          return {
            caption: caption,
            value: word[0] + ((word[1] != null)? "(": ""),
            meta: word[1] == null? "parameter": "function"
          };
        }));
      }
    }
    eCode.editor.completers.unshift(staticWordCompleter);
    if(!eCode.editor.completer) {
      // make sure completer is initialized
      eCode.editor.execCommand("startAutocomplete")
      eCode.editor.completer.detach()
    }
    eCode.editor.completer.popup.container.style.width = "60%";
}
AddAutoCompletion(eCode.editor, [
	["Texture.FromShader", ["exprOrShader", "width=CanvasSize[0]", "height=CanvasSize[1]", "format='byte4'", "inputTexturesArr=[]", "params=[]"]],
	["new ShaderExpression", ["expr", "numComponents"]],
	["Export", ["name"]]
]);
AddAutoCompletion(eShaderCode.editor, [
	["TexCoord", null]
]);


Http({
  path: "docs.html",
  then: function(r) {
    eDocs.innerHTML = r.response;
  }
});

function Tabs(id) {
  this.element = (typeof id === 'string')? document.getElementById(id): id;
  this.events = new Events(this);
  this.attach();
}

Tabs.prototype.attach = function () {
  this.tabs = this.getElements(this.element, '[data-tab]');
  this.pages = this.getElements(this.element, '[data-page]');

  this.tabs.forEach(function (tab, idx) {
    tab.addEventListener('click', this.select.bind(this, idx));
  }, this);
}

Tabs.prototype.select = function (idx, event) {
  if (idx < 0 || idx >= this.tabs.length) return;
  var tab = this.tabs[idx];
  var id = tab.getAttribute('data-tab');

  this.tabs.forEach(function (_tab) {
    if (_tab == tab) _tab.classList.add('tab-active');
    else _tab.classList.remove('tab-active');
  }, this);

  this.pages.forEach(function (page) {
    var pageId = page.getAttribute('data-page');
    if (pageId == id) page.classList.add('page-active');
    else page.classList.remove('page-active');
  }, this);

  this.events.fire('change', idx);
}

Tabs.prototype.getElements = function (el, selector) {
  return [].slice.call(el.querySelectorAll(selector));
}

// --- Splitter

function Splitter(id, options) {
  this.element = (typeof id === 'string') ? document.getElementById(id) : id;
  this.options = options || {};

  if (!this.options.cookieKey) this.options.cookieKey = null;
  if (!this.options.minWidth) this.options.minWidth = 0;

  this.binds = {
    start: this.start.bind(this),
    move: this.move.bind(this),
    end: this.end.bind(this)
  };

  this.attach();
}

Splitter.prototype.attach = function () {
  this.left = this.element.previousElementSibling;
  this.right = this.element.nextElementSibling;

  // TODO: load from cookie?

  this.dragging = false;

  this.element.addEventListener('mousedown', this.binds.start);
}

Splitter.prototype.start = function (event) {
  var isLeftButton = (event.which ? (event.which == 1) : false) ||
    (event.button ? (event.button == 1) : false);
  if (!isLeftButton) return;

  event.stopPropagation();
  event.preventDefault();

  this.startPos = this.eventPosition(event);

  // Add transparent cover to avoid IFRAMEs
  if (!this.cover) {
    this.cover = document.createElement('div');
    this.cover.style.position = 'fixed';
    this.cover.style.top = '0px';
    this.cover.style.bottom = '0px';
    this.cover.style.left = '0px';
    this.cover.style.right = '0px';
    this.cover.style.cursor = this.getComputedStyle(this.element, 'cursor');
    document.body.appendChild(this.cover);
  } else {
    this.cover.style.display = 'block';
  }

  document.body.addEventListener('mousemove', this.binds.move);
  document.body.addEventListener('mouseup', this.binds.end);
  this.dragging = true;

  var iframes = document.querySelectorAll('iframe');
  for(var i = 0; i < iframes.length; i++)
    iframes[i].style.pointerEvents = 'none';
}

Splitter.prototype.move = function (event) {
  if (!this.dragging) return;

  event.stopPropagation();
  event.preventDefault();

  var pos = this.eventPosition(event);

  // TODO: resize
  var delta = pos.x - this.startPos.x;
  this.startPos = pos;

  //console.log(delta);

  var leftWidth = this.left.offsetWidth;
  var rightWidth = this.right.offsetWidth;

  //console.log(leftWidth, rightWidth);

  if (delta < 0) {
    if ((leftWidth + delta) < this.options.minWidth) delta -= this.options.minWidth - (leftWidth + delta);
  } else {
    if ((rightWidth - delta) < this.options.minWidth) delta -= this.options.minWidth - (rightWidth - delta);
  }

  this.left.style.width = (leftWidth + delta) + 'px';
  this.right.style.width = (rightWidth - delta) + 'px';
}

Splitter.prototype.end = function (event) {
  if (!this.dragging) return;

  event.stopPropagation();
  event.preventDefault();

  this.cover.style.display = 'none';

  var pos = this.eventPosition(event);

  // TODO: end dragging, fix new sizes

  // TODO: save to cookie?

  var iframes = document.querySelectorAll('iframe');
  for(var i = 0; i < iframes.length; i++)
    iframes[i].style.pointerEvents = 'auto';

  document.body.removeEventListener('mousemove', this.binds.move);
  document.body.removeEventListener('mouseup', this.binds.end);
  this.dragging = false;
}

Splitter.prototype.eventPosition = function (event) {
  var pageX = event.pageX;
  var pageY = event.pageY;
  if (pageX === undefined) {
    pageX = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
    pageY = event.clientY + document.body.scrollTop + document.documentElement.scrollTop;
  }
  return {
    x: pageX,
    y: pageY
  };
}

Splitter.prototype.getComputedStyle = function (elem, prop) {
  if (elem.currentStyle) {
    return elem.currentStyle[prop];
  } else if (window.getComputedStyle) {
    return window.getComputedStyle(elem, null).getPropertyValue(prop);
  }
}

// ---

window.addEventListener('DOMContentLoaded', function () {
  var splitterEl = document.querySelector('[data-splitter]');
  new Splitter(splitterEl/*, {minWidth: 200}*/);

  var tabsEl = document.querySelectorAll('[data-tabs]');
  var tabs = new Tabs(tabsEl[0]);
  var tabsRight = new Tabs(tabsEl[1]);

  //ReplaceTextAreasWithAce();

  tabs.events.add('change', function (idx) {
    if(idx == 0) eCode.editor.focus();
    else eShaderCode.editor.focus();
  });

  if (window == window.top)
    eCode.editor.focus();
});


var Events = function (context) {
  this.context = context || null;
  this.events = {};
}

Events.prototype.add = function (event, listener) {
  if (typeof this.events[event] !== 'object') {
    this.events[event] = [];
  }

  this.events[event].push(listener);
}

Events.prototype.adds = function (events) {
  Object.forEach(events, function (listener, event) {
    this.add(event, listener);
  }, this);
}

Events.prototype.remove = function (event, listener) {
  var idx;

  if (typeof this.events[event] === 'object') {
    idx = this.events[event].indexOf(listener);

    if (idx > -1) {
      this.events[event].splice(idx, 1);
    }
  }
}

Events.prototype.fire = function (event) {
  var i, listeners, length, args = [].slice.call(arguments, 1);

  if (typeof this.events[event] === 'object') {
    listeners = this.events[event].slice();
    length = listeners.length;

    for (i = 0; i < length; i++) {
      listeners[i].apply(this.context, args);
    }
  }
}

Events.prototype.fireOnce = function (event, listener) {
  this.add(event, function g() {
    this.remove(event, g);
    listener.apply(this.context, arguments);
  });
}

window.onbeforeunload = function(e) {
	if(!app.documentChanged) return;
	var dialogText = 'Вы уверены, что хотите закрыть страницу без сохранения изменений?';
	e.returnValue = dialogText;
	return dialogText;
};

document.onkeydown = function(e)
{
	if(e.shiftKey && e.keyCode == 13)
	{
		Generate();
		return false;
	}
	if(e.keyCode == 117 || e.ctrlKey && e.keyCode == 76) //F6, Ctrl+L
	{
		Save(false);
		return true;
	}
};
</script>

<script src="BsonLib.js" onload="Load()"></script>
</body>
</html>
