<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>SynthGen Result</title>

<style>
html,
body {
    width: 100%;
    height: 100%;
    border: 0;
	margin: 0;
	color: white;
}
.error {
	color: indianred;
}
.warning {
	color: gold;
}

*::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

*::-webkit-scrollbar-button {
    width: 0px;
    height: 0px;
}

*::-webkit-scrollbar-thumb {
    background: #555;
    border: none;
    border-radius: 0px;
}

*::-webkit-scrollbar-thumb:hover {
    background: #666;
}

*::-webkit-scrollbar-thumb:active {
    background: #666;
}

*::-webkit-scrollbar-track {
    background: #141414;
    border: 0px none white;
    border-radius: 0px;
}

*::-webkit-scrollbar-corner {
    background: transparent;
}

.canvas-content {
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	overflow-wrap: break-word;
	background: rgba(0, 0, 0, 0.5)
}



.menu-bar {
  overflow: hidden;
  font-family: Arial, Helvetica, sans-serif;
}

.menu-bar a {
  float: left;
  font-size: 12px;
  color: white;
  text-align: center;
  padding: 4px 8px;
  text-decoration: none;
  background-color: rgba(32, 32, 32, 0.6);
}

.dropdown {
  float: left;
  overflow: hidden;
}

.dropdown .dropbtn {
  cursor: pointer;
  font-size: 12px;    
  border: none;
  outline: none;
  color: white;
  padding: 4px 8px;
  background-color: inherit;
  font-family: inherit;
  margin: 0;
}

.menu-bar a:hover, .dropdown:hover .dropbtn, .dropbtn:focus {
  background-color: #25a;
}

.dropdown-content {
  display: none;
  position: absolute;
  background-color: rgba(32, 32, 32, 0.6);
  min-width: 80px;
  box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
  z-index: 503;
}

.dropdown-content a {
  float: none;
  color: white;
  padding: 4px 8px;
  text-decoration: none;
  display: block;
  text-align: left;
}

.dropdown-content a:hover {
  background-color: #25a;
}

.dropdown-show {
  display: block;
  z-index: 500;
}

</style>

</head>

<body>
<script id="VertexShaderCode" type="x-shader/x-vertex">
#version 100
attribute vec2 aTexCoord;
varying vec2 TexCoord;
void main()
{
	TexCoord = aTexCoord;
	gl_Position = vec4(TexCoord*2.0 - 1.0, 0.0, 1.0);
}
</script>

<script id="FragmentExportShaderCode" type="x-shader/x-fragment">
#version 100
precision mediump float;
varying vec2 TexCoord;
uniform sampler2D TexA;
void main()
{
	gl_FragColor = texture2D(TexA, TexCoord);
}
</script>

<script id="FragmentShaderCodeStart" type="x-shader/x-fragment">
#version 100

#ifdef GL_ES

#ifdef GL_FRAGMENT_PRECISION_HIGH

#if GL_FRAGMENT_PRECISION_HIGH == 1
precision highp float;
#else
precision mediump float;
#endif

#else
precision mediump float;
#endif

#endif

varying vec2 TexCoord;
uniform vec2 TextureSize;
uniform sampler2D TexA, TexB, TexC, TexD, TexE, TexF, TexG, TexH;
uniform vec2 TexASize, TexBSize, TexCSize, TexDSize, TexESize, TexFSize, TexHSize;

vec4 synthgen_internal_rgba(float x) {return vec4(x, x, x, 1.0);}
vec4 synthgen_internal_rgba(vec2 x) {return vec4(x.xy, 0.0, 1.0);}
vec4 synthgen_internal_rgba(vec3 x) {return vec4(x, 1.0);}
vec4 synthgen_internal_rgba(vec4 x) {return x;}
</script>

<script>
window.onclick = function(e) {
	if(e.target.matches('.dropbtn')) return;
	var elements = document.getElementsByClassName('dropdown-show');
	for(var i = 0; i < elements.length; i++)
		elements[i].classList.remove('dropdown-show');
}
</script>

	<div style="display:none">
		<div id="eSmallCanvasTemplate" style="position: relative; display: inline-block">
			<canvas></canvas>
			<div class="canvas-content">
				<div class="menu-bar">
					<div class="dropdown">
						<button class="dropbtn" onclick="this.nextElementSibling.classList.toggle('dropdown-show')">Сохранить</button>
						<div class="dropdown-content">
							<a href="#" onclick="OnSaveImageButton(this, 'png')">PNG</a>
							<a href="#" onclick="OnSaveImageButton(this, 'jpg')">JPEG</a>
							<a href="#" onclick="OnSaveImageButton(this, 'webp')">WEBP</a>
							<a href="#" onclick="OnSaveImageButton(this, 'bmp')">BMP</a>
						</div>
					</div>
				</div>
				<span name="name"></span>
			</div>
		</div>
	</div>

	<span id="eLogOutput"></span>
	<span id="eResults">
		<div id="eMainCanvasContainer" style="position: relative">
			<canvas id="eMainCanvas"></canvas>
			<div class="canvas-content"></div>
		</div>
		<div id="eSmallCanvases"></div>
	</span>
</body>

<script src="utils.js"></script>

<script>
var gResults = eResults;

gLog = "";

function ClearLog()
{
	gLog = "";
}

function Log(str)
{
	gLog += str;
}

function LogError(str)
{
	gLog += "<span class='error'>" + str + "</span><br/>";
	console.log(str);
}

function LogWarning(str)
{
	gLog += "<span class='warning'>" + str + "</span>";
	console.log(str);
}

function GetLog()
{
	return gLog;
}

var gShaderLibraryLoader = LoadShaderAsync("ShaderLib.glsl");
var gShaderInputCode = null;

var gOffScreenCanvas = document.createElement("canvas");
var gFBO = null;

function InitGL(canvas)
{
	var gl = canvas.getContext("webgl2", {antialias : false});
	if(!gl)
	{
		gl = canvas.getContext("webgl", {antialias : false}) ||
			canvas.getContext("experimental-webgl", {antialias : false});
		if(gl) gl.version = 10;
	}
	else gl.version = 20;

	if(!gl) return null;

	gl.extTextureFloat = gl.getExtension("OES_texture_float");
	gl.extTextureFloatLinear = gl.getExtension("OES_texture_float_linear");
	gl.extTextureHalfFloat = gl.getExtension("OES_texture_half_float");
	gl.extTextureHalfFloatLinear = gl.getExtension("OES_texture_half_float_linear");
	if(gl.version >= 20) gl.getExtension("EXT_color_buffer_float");
	else gl.getExtension("WEBGL_color_buffer_float");
	var floatTextureRenderSupported = gl.version >= 20 || gl.extTextureFloat && gl.extTextureFloatLinear;
	var halfFloatTextureRenderSupported = gl.version >= 20 || gl.extTextureHalfFloat && gl.extTextureHalfFloatLinear;
	if(gl.version < 20 && halfFloatTextureRenderSupported) gl.HALF_FLOAT = gl.extTextureHalfFloat.HALF_FLOAT_OES;

	gl.state = {
		currentFBO: null,
		activeTextures: [null, null, null, null, null, null, null, null],
		activeTextureSlot: 0,
		currentProgram: null,
		numTexturesCreated: 0,
		numTexturesDeleted: 0
	}

	return gl;
}
var gl = InitGL(gOffScreenCanvas);

function BindTextures(textures, samplerLocs)
{
	var count = Math.min(gl.state.activeTextures.length, Math.max(textures.length, samplerLocs? samplerLocs.length: 0));
	for(var i = 0; i < count; i++)
	{
		if(gl.state.activeTextureSlot !== i)
		{
			gl.activeTexture(gl.TEXTURE0 + i);
			gl.state.activeTextureSlot = i;
		}
		var tex = textures[i];
		if(tex === undefined && samplerLocs)
		{
			if(samplerLocs[i] !== null)
			{
				gl.bindTexture(gl.TEXTURE_2D, null);
				LogError("BindTextures: null texture! samplerLocs[" + i + " / " + samplerLocs.length + "] = " + samplerLocs[i]);
			}
			continue;
		}
		gl.bindTexture(gl.TEXTURE_2D, gl.state.activeTextures[i] = tex.id);
	}
}

function BindFramebuffer(fbo)
{
	if(gl.state.currentFBO !== fbo)
		gl.bindFramebuffer(gl.FRAMEBUFFER, gl.state.currentFBO = fbo);
}

function Shader(code, type)
{
	this.code = code;
	this.type = type;
	this.id = gl.createShader(type);
	gl.shaderSource(this.id, code);
	gl.compileShader(this.id);
	var log = gl.getShaderInfoLog(this.id);
	var success = gl.getShaderParameter(this.id, gl.COMPILE_STATUS);
	if(!success || log.toLowerCase().indexOf("warn") !== -1)
	{
		if(!log.endsWith('\n')) log += "\n";
		(success? LogWarning: LogError)(EscapeHTML(log));
		console.log(log);
	}
	if(success) return;
	gl.deleteShader(this.id);
	this.id = null;
}

Shader.prototype.Free = function()
{
	if(this.id === null) return;
	gl.deleteShader(this.id);
	this.id = null;
}


function ShaderProgram(vertexShader, fragmentShader)
{
	if(vertexShader instanceof Shader) this.vertex = vertexShader;
	else this.vertex = new Shader(vertexShader, gl.VERTEX_SHADER);
	if(fragmentShader instanceof Shader) this.fragment = fragmentShader;
	else this.fragment = new Shader(fragmentShader, gl.FRAGMENT_SHADER);

	this.id = gl.createProgram();
	gl.attachShader(this.id, this.vertex.id);
	gl.attachShader(this.id, this.fragment.id);
	gl.linkProgram(this.id);
	gl.detachShader(this.id, this.vertex.id);
	gl.detachShader(this.id, this.fragment.id);
	var success = gl.getProgramParameter(this.id, gl.LINK_STATUS);
	var log = gl.getProgramInfoLog(this.id);
	if(!success || log.toLowerCase().indexOf("warn") !== -1)
	{
		if(!log.endsWith('\n')) log += "\n";
		(success? LogWarning: LogError)(EscapeHTML(log));
		console.log(log);
	}
	
	if(!(vertexShader instanceof Shader)) this.vertex.Free();
	if(!(fragmentShader instanceof Shader)) this.fragment.Free();
	
	if(!success)
	{
		gl.deleteProgram(this.id);
		this.id = null;
	}
}

ShaderProgram.prototype.Free = function()
{
	if(this.id === null) return;
	gl.deleteProgram(this.id);
	this.id = null;
}

ShaderProgram.prototype.Bind = function()
{
	if(gl.state.currentProgram === this.id) return;
	gl.useProgram(gl.state.currentProgram = this.id);
}

function GetShaderCode(id)
{
    var shaderScript = document.getElementById(id);
    if(!shaderScript) return null;
    var str = "";
    var k = shaderScript.firstChild;
    while(k)
    {
        if(k.nodeType == 3)
            str += k.textContent;
        k = k.nextSibling;
    }
	return str;
}

if(gl)
{
	gCommonVertexShader = new Shader(GetShaderCode("VertexShaderCode"), gl.VERTEX_SHADER);
	gExportFragmentShader = new Shader(GetShaderCode("FragmentExportShaderCode"), gl.FRAGMENT_SHADER);
	gExportShaderProgram = new ShaderProgram(gCommonVertexShader, gExportFragmentShader);
	gExportShaderProgram.samplerLocs = [0];

	var gQuadBufferId = function()
	{
		var buffer = new ArrayBuffer(32);
		new Float32Array(buffer).set([0,0, 1,0, 0,1, 1,1]);
		var bufId = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, bufId);
		gl.bufferData(gl.ARRAY_BUFFER, buffer, gl.STATIC_DRAW);
		return bufId;
	}();

	gFBO = gl.createFramebuffer();
}
else
{
	LogError("WebGL is not supported!");
}

function ParseGLType(str)
{
	switch(str)
	{
	case "byte": return gl.UNSIGNED_BYTE;
	case "sbyte": return gl.BYTE;
	case "ushort": return gl.UNSIGNED_SHORT;
	case "short": return gl.SHORT;
	case "float": return gl.FLOAT;
	case "int": return gl.INT;
	case "uint": return gl.UNSIGNED_INT;
	case "half": return gl.HALF_FLOAT;
	}
	return null;
}

function ParseWebGL2InternalFormat(str)
{
	switch(str)
	{
	case "byte1": return gl.R8;
	case "half1": return gl.R16F;
	case "float1": return gl.R32F;
	
	case "byte2": return gl.RG8;
	case "half2": return gl.RG16F;
	case "float2": return gl.RG32F;
	
	case "byte3": return gl.RGB8;
	case "half3": return gl.RGB16F;
	case "float3": return gl.RGB32F;
	
	case "byte4": return gl.RGBA8;
	case "half4": return gl.RGBA16F;
	case "float4": return gl.RGBA32F;
	}
	return null;
}

function ParseTextureFormat(str)
{
	var numComponents = str.charCodeAt(str.length - 1) - 48;
	if(numComponents < 1 || numComponents > 4)
	{
		LogError("Invalid texture format " + EscapeHTML(str) + "!");
		return null;
	}
	var typeStr = str.slice(0, -1);
	var type = ParseGLType(typeStr);
	var format = [gl.version >= 20? gl.RED: null, gl.version >= 20? gl.RG: null, gl.RGB, gl.RGBA][numComponents-1];
	var internalFormat = format;
	if(gl.version >= 20)
	{
		internalFormat = ParseWebGL2InternalFormat(str);
		if(!internalFormat)
		{
			LogError("Invalid texture format " + EscapeHTML(str) + "!");
			return null;
		}
	}
	return {
		numComponents: numComponents,
		type: type,
		format: format,
		internalFormat: internalFormat
	};
}

function Texture(width, height, format, mipmapped)
{
	if(mipmapped === undefined) mipmapped = false;
	var glfmt = ParseTextureFormat(format);
	if(!glfmt)
	{
		LogError("Invalid texture format " + EscapeHTML(format) + "!");
		return;
	}
	this.numComponents = glfmt.numComponents;
	this.type = glfmt.type;
	this.format = glfmt.format;
	this.internalFormat = glfmt.internalFormat;
	this.formatStr = format;
	this.width = width;
	this.height = height;
	this.id = gl.createTexture();
	this.id.index = this.index = gl.state.numTexturesCreated++;

	gl.bindTexture(gl.TEXTURE_2D, gl.state.activeTextures[gl.state.activeTextureSlot] = this.id);

	gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, this.width, this.height, 0, this.format, this.type, null);
	var isLinearFilteringUnsupported = gl.version < 20 && (
		format.startsWith("half") && !gl.extTextureHalfFloatLinear ||
		format.startsWith("float") && !gl.extTextureFloatLinear);
	if(isLinearFilteringUnsupported)
	{
		LogWarning("LINEAR filtering for texture format " + EscapeHTML(format) + " is not supported! Using NEAREST instead.<br/>");
		mipmapped = false;
	}
	this.mipmapped = mipmapped;
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, isLinearFilteringUnsupported? gl.NEAREST: gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, isLinearFilteringUnsupported? gl.NEAREST: (mipmapped? gl.LINEAR_MIPMAP_LINEAR: gl.LINEAR));
	gResults.textures.push(this);
}

ShaderProgram.FromExpression = function(expr)
{
	if(gResults.shaders[expr] && gResults.shaders[expr].id)
		return gResults.shaders[expr];
	
	var code = GetShaderCode("FragmentShaderCodeStart");
	if(gShaderLibraryLoader.code) code += "#line 1 0\n" + gShaderLibraryLoader.code;
	code += "\n#line 1 1\n";
	code += gShaderInputCode;
	code += "\n#line 1 2\nvoid main() {gl_FragColor = synthgen_internal_rgba(" + expr + ");}";

	var result = new ShaderProgram(gCommonVertexShader, code);
	if(result.id === null)
	{
		LogError("Couldn't compile expression \"" + EscapeHTML(expr) + "\"!");
		return null;
	}
	result.expr = expr;
	result.textureSizeLoc = gl.getUniformLocation(result.id, "TextureSize");
	result.samplerLocs = [];
	result.textureSizeLocs = [];
	
	result.Bind();
	for(var i=0; i<8; i++)
	{
		var uniformName = "Tex" + String.fromCharCode(65 + i);
		var loc = gl.getUniformLocation(result.id, uniformName);
		result.samplerLocs.push(loc);
		var sizeLoc = gl.getUniformLocation(result.id, uniformName + "Size");
		result.textureSizeLocs.push(sizeLoc);
		if(loc == -1) continue;
		gl.uniform1i(loc, i);
	}
	
	gResults.shaders[expr] = result;
	return result;
}

function DrawFullScreenQuad()
{
	gl.bindBuffer(gl.ARRAY_BUFFER, gQuadBufferId);
	gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 8, 0);
	gl.enableVertexAttribArray(0);
	gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
	gl.disableVertexAttribArray(0);
}

function FillViewportWithShader(exprOrShader, width, height, inputTextures)
{
	var shader;
	if(exprOrShader instanceof ShaderProgram) shader = exprOrShader;
	else if(typeof exprOrShader == 'string' || exprOrShader instanceof String)
		shader = ShaderProgram.FromExpression(exprOrShader);
	else
	{
		LogError("FillViewportWithShader: invalid type of first argument! Expected ShaderProgram or string, got: " + JSON.stringify(exprOrShader));
		return false;
	}
	if(shader.id === null)
	{
		LogError("FillViewportWithShader: null shader!");
		return false;
	}

	shader.Bind();
	
	if(shader.textureSizeLoc !== undefined && shader.textureSizeLoc != -1)
		gl.uniform2f(shader.textureSizeLoc, width, height);

	var numTex = Math.min(inputTextures.length, shader.samplerLocs.length);

	BindTextures(inputTextures, shader.samplerLocs);
	
	for(var i=0; i<numTex; i++)
	{
		if(shader.textureSizeLocs)
		{
			var tsloc = shader.textureSizeLocs[i];
			if(tsloc !== undefined && tsloc !== null)
				gl.uniform2f(tsloc, inputTextures[i].width, inputTextures[i].height);
		}
	}
	
	gl.viewport(0, 0, width, height);
	DrawFullScreenQuad();
	
	if(shader !== exprOrShader)
	{
		gl.deleteProgram(shader.id);
		gResults.shaders[shader.expr] = undefined;
	}

	return true;
}

Texture.FromShader = function(/*exprOrShader, [width=CanvasSize.x, height=CanvasSize.y], [format="byte4"], [inputTextures = []], [params = {}]*/)
{
	function impl(exprOrShader, width, height, format, inputTextures, params)
	{
		if(inputTextures === undefined) inputTextures = [];
		if(params === undefined) params = {};
		var result = new Texture(width, height, format, params.mipmapped);
		if(result.id == null) return result;
		
		BindFramebuffer(gFBO);
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, result.id, 0);
		var success = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
		if(!success)
		{
			LogError("Error: framebuffer incomplete status 0x" + fbStatus.toString(16));
			result.Free();
			return result;
		}
		else
		{
			success = FillViewportWithShader(exprOrShader, width, height, inputTextures);
			if(!success) result.Free();
			else if(result.mipmapped) gl.generateMipmap(gl.TEXTURE_2D);
		}
		return result;
	}
	if(!isNaN(arguments[1]))
	{
		if(typeof(arguments[3]) == "string") return impl(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
		return impl(arguments[0], arguments[1], arguments[2], "byte4", arguments[3], arguments[4]);
	}
	if(typeof(arguments[1]) == "string") return impl(arguments[0], CanvasSize[0], CanvasSize[1], arguments[1], arguments[2], arguments[3]);
	return impl(arguments[0], CanvasSize[0], CanvasSize[1], "byte4", arguments[1], arguments[2]);
}
var TextureFromShader = Texture.FromShader;

Texture.prototype.Free = function()
{
	gResults[this.name] = undefined;
	if(this.id === null) return;
	gl.deleteTexture(this.id);
	this.id = null;
	gl.state.numTexturesDeleted++;
}
function DeleteTexture(tex) {tex.Free();}

function CreateImageFromTexture(tex, name)
{
	if(tex.formatStr != "byte4")
	{
		var tex2 = Texture.FromShader(gExportShaderProgram, tex.width, tex.height, "byte4", [tex], {mipmapped: false});
		var result = CreateImageFromTexture(tex2, name + "->byte4");
		tex2.Free();
		return result;
	}
	gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex.id, 0);
	var pixels = new Uint8Array(tex.width*tex.height*tex.numComponents);
	gl.readPixels(0, 0, tex.width, tex.height, tex.format, tex.type, pixels);
	return CreateImageFromPixels(pixels, tex.width, tex.height);
}

Texture.prototype.ToCanvas = function(dstCanvas)
{
	if(!dstCanvas) dstCanvas = gOffScreenCanvas;
	if(dstCanvas !== gOffScreenCanvas &&
		(gOffScreenCanvas.width !== dstCanvas.width ||
		gOffScreenCanvas.height !== dstCanvas.height))
	{
		gOffScreenCanvas.width = dstCanvas.width;
		gOffScreenCanvas.height = dstCanvas.height;
	}
	BindFramebuffer(null);
	FillViewportWithShader(gExportShaderProgram, gOffScreenCanvas.width, gOffScreenCanvas.height, [this]);
	if(dstCanvas !== gOffScreenCanvas)
	{
		if(!dstCanvas.context) dstCanvas.context = dstCanvas.getContext("2d");
		dstCanvas.context.drawImage(gOffScreenCanvas, 0, 0);
	}
}

Texture.prototype.ToTempCanvas = function()
{
	if(gOffScreenCanvas.width != this.width ||
		gOffScreenCanvas.height != this.height)
	{
		gOffScreenCanvas.width = this.width;
		gOffScreenCanvas.height = this.height;
	}
	BindFramebuffer(null);
	FillViewportWithShader(gExportShaderProgram, gOffScreenCanvas.width, gOffScreenCanvas.height, [this]);
	return gOffScreenCanvas;
}

Texture.prototype.Export = function(name)
{
	gResults.exportedTextures[name] = this;
	return this;
}
function ExportTexture(tex, name) {tex.Export(name);}

function CleanUpResults()
{
	ClearLog();
	gl.useProgram(gl.state.currentProgram = null);
	if(gResults.shaders)
	for(var shaderKey in gResults.shaders)
	{
		var shader = gResults.shaders[shaderKey];
		if(shader) shader.Free();
	}
	gResults.shaders = {};
	
	if(gResults.textures)
	gResults.textures.forEach(function(tex) {
		tex.Free();
	});
	gResults.textures = [];
	
	gResults.exportedTextures = {};
}
window.onunload = function(event) {
	CleanUpResults();
	return false;
};

var CanvasSize = [512, 512];
var gCanvases = [];

function OnSaveImageButton(node, ext) {
	var canvas = node.parentNode.parentNode.parentNode.parentNode.previousElementSibling;
	var name = canvas.textureName;
	var filename = name.replace(/[\W_]+/g, "_") + "." + ext;
	switch(ext) {
		case "png": SaveCanvasPNG(gResults.exportedTextures[name].ToTempCanvas(), filename); break;
		case "jpg": SaveCanvasJPEG(gResults.exportedTextures[name].ToTempCanvas(), filename); break;
		case "webp": if(ChromeVersion) SaveCanvasWEBP(gResults.exportedTextures[name].ToTempCanvas(), filename); break;
		case "bmp": SaveCanvasBMP(gResults.exportedTextures[name].ToTempCanvas(), filename); break;
	}
}

//if(!ChromeVersion) eSaveWEBP.style.display = "none";

function SelectTextureToShow(name)
{
	gSelectedTextureName = name;
	if(!name) return;
	gResults.exportedTextures[name].ToCanvas(eMainCanvas);
	eMainCanvas.textureName = name;
}

function Generate(controlCode, shaderCode)
{
	CleanUpResults();
	var genfunc = function() {
		CanvasSize = [512, 512];
		gShaderInputCode = shaderCode;
		try {eval(controlCode);}
		catch(err)
		{
			if(err.stack) LogError(EscapeHTML(err.stack));
			else LogError(EscapeHTML(err.toString()));
		}
		if(GetLog()) eLogOutput.innerHTML = "<p>" + GetLog() + "</p>";
		var i = 0;
		for(var name in gResults.exportedTextures)
		{
			var tex = gResults.exportedTextures[name];
			var canvas;
			if(i >= gCanvases.length)
			{
				var canvasContainer = eSmallCanvasTemplate.cloneNode(true);
				canvasContainer.id = "" + i;
				canvas = canvasContainer.firstElementChild;
				canvas.width = canvas.height = 128;
				canvasContainer.style.width = canvasContainer.style.height = "128px";
				eSmallCanvases.appendChild(canvasContainer);
				gCanvases.push(canvasContainer);
			}
			else canvas = gCanvases[i].firstElementChild;
			gCanvases[i].querySelector('span[name="name"]').innerText = name;
			tex.ToCanvas(canvas);
			canvas.textureName = name;
			i++;
		}
		while(i < gCanvases.length)
		{
			var canvasContainer = gCanvases.pop();
			eSmallCanvases.removeChild(canvasContainer);
			var canvas = canvasContainer.firstElementChild;
			canvas.width = 0;
			canvas.height = 0;
		}
		eMainCanvasContainer.style.width = CanvasSize[0] + "px";
		eMainCanvasContainer.style.height = CanvasSize[1] + "px";
		if(eMainCanvas.width != CanvasSize[0]) eMainCanvas.width = CanvasSize[0];
		if(eMainCanvas.height != CanvasSize[1]) eMainCanvas.height = CanvasSize[1];
		SelectTextureToShow(gCanvases[0].firstElementChild.textureName);
	}
	if(gShaderLibraryLoader.code !== undefined) genfunc();
	else gShaderLibraryLoader.onload = genfunc;
}
    
function receiveMessage(event)
{
	if(!event.origin.startsWith(location.origin)) return;
    Generate(event.data.controlCode, event.data.glsl);
}
window.addEventListener("message", receiveMessage, false);
</script>
